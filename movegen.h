/*******************************************************
* Generates the possible moves and stores the new configuration. 

* The moves are generated by bitsift operations & the bitboard stored 
	at the time of initialisation of the board.

* Author : Prateek Vaishnav 
	   Gaurav Kishore

*********************************************************/ 

#include<iostream>

using namespace std;


class node{
	public:
		int ply;
		U64 Pieces[2][7];
		U64 Config[2][7];
		node *parent;
		node *child[100];
		int no_of_child;
		int score;
		int fromsq;
		int tosq;
		//int piece;
		node()
		{
			parent = NULL;
			score = 0;
			no_of_child = 0;
			for(int i=0; i<100;i++)
				child[i]=NULL;
		}
		  
}*root;

int castling[2][2];     // true till castling is allowed 

// generates utility boards ///
void genUtilBoards(U64 Pieces[2][7]);
int bitboardToMoves(node *present,U64 board, int piece, int fromsq, int ply);

// generates the possible moves of the various pieces
U64 genBishopAttackBoard(int sq);
U64 genRookAttackBoard(int sq);
U64 genQueenAttackBoard(int sq);
U64 genPawnAttackBoard(int side,int sq);
U64 genKnightAttackBoard(int sq);
U64 genKingAttackBoard(int sq);
////////////////////////////////////////////////////


int generateAllMoves(node* present,int ply,U64 Pieces[2][7]);
void genattackboard(int side,U64 Pieces[2][7]);


